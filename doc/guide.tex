\documentclass[a4paper,10pt]{book}
\usepackage{t1enc}
\usepackage[english]{babel}
\usepackage{calc}
\usepackage{amsmath,amssymb}
\usepackage{epsfig}
%\usepackage{fourier}
\usepackage{times}
\usepackage{a4wide}
\usepackage{url}
\usepackage{fancyhdr}
\usepackage{array,longtable}
\usepackage{color}
\usepackage{listings}

\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}

\definecolor{orange}{rgb}{1,0.5,0}
\definecolor{blue}{rgb}{0.3,0.3,0.9}

\newcommand{\file}[1] {\textcolor{blue}{\textsf{#1}}}
\newcommand{\parameter}[1] {\textcolor{orange}{\textsf{#1}}}


\title{Puma-EM User's guide}
\author{Idesbald van den Bosch}

\begin{document}
\maketitle
\tableofcontents

\chapter{Introduction}
%
\par
Puma-EM is a code that allows the computation of various electromagnetic quantities when a target is excited by an electromagnetic source. These quantities are the scattered fields and the currents on the surface of the target. It can compute:
\begin{itemize}
\item monostatic RCS for a variety of angles or positions (SAR)
\item bistatic RCS for a variety of angles
\item Antenna pattern
\item electric and/or magnetic dipole excitation
\item plane-wave excitation
\item a combination of the above
\item \ldots
\end{itemize}
%
\par
The target is for now a perfect electric conductor (PEC). The method used is the boundary elements method, also commonly known as the method of moments (MOM). The basis functions used are the Rao-Wilton-Glisson triangular rooftops. The integral equation implemented is the combined fields integral equation (CFIE) formulation, which can be degenerated into an electric field integral equation (EFIE) or magnetic field integral equation (MFIE). 
%
\par
Puma-EM also makes use of the Multilevel fast multipole method (MLFMM or MLFMA) for speeding up the computations and also allowing a larger number of basis RWG functions (and hence allowing to solve larger problems) than with the classical MOM. 
%
\par
In addition to the MLFMM, Puma-EM is parallelized and can run on laptop, desktop and homogeneous cluster architectures. The rule of thumb for the number of unknowns Puma-EM can reasonably handle per GByte of memory is between $500,000$ and $2,000,000$ (depending upon the problem specificities and the details of the machine architecture). For example, Puma-EM has solved the monostatic scattering of a cubic target involving $53.9$ million of unknowns, on a cluster of 2 machines having each ``only'' 16 GBytes of memory. It can routinely solve in a few hours problems involving more than 1 million of unkowns of a low-end (dated 2004) 2 GByte laptop.


\chapter{Installing}

\section{Linux}
%
\par
Installing can be tricky, as Puma-EM depends upon numerous libraries, some of which are still under active development. However, to make it easier, some distributions are supported through an automated installation procedure. These are Ubuntu, Fedora, OpenSuse and CentOS. To install on these distributions, simply type 
\begin{verbatim}
puma-em$ ./install.sh
\end{verbatim}
and follow the instructions on screen.
%
\par
If your distribution is not supported out-of-the-box, it is possible that is is a close relative to one of the distributions cited above, for example, Red Hat or Debian. In that case, have a look at the scripts located in the directory \begin{verbatim}installScripts\end{verbatim}, pick the one that corresponds to the closest relative to your distribution, and run the installation script.

\par
If your distribution is not supported out-of-the-box and is not a close relative to Debian/Red Hat, here is a list of the libraries Puma-EM depends upon:
\begin{enumerate}
\item the compiler suite g++ and gfortran (or g77)
\item the python interpreter (included by default in most distributions)
\item scipy, an open source scientific library for python
\item matplotlib, a powerful plotting tool for python
\item GMSH, an open source CAD and mesh generator
\item blitz++
\item open-mpi or lam-mpi, an open-source message passing interface library
\item mpi4py 0.6.0, an open-source message passing interface library tuned for Python
\end{enumerate}

\section{Mac OS X}
%
\par
If Puma-EM has run on a Mac OS computer, I am not aware of it. However, Mac OS is a BSD system, and ports exist between Linux libraries and programs and Mac OS. See the darwinports website \url{http://darwinports.com/}. Here are some --- possibly outdated --- hints:
\begin{itemize}
\item g++ and gfortran
\item Open-MPI (\url{http://permalink.gmane.org/gmane.comp.clustering.open-mpi.user/10347} and \url{http://openmpi.darwinports.com/})
\item GMSH (yes you can: this one works on Mac: \url{http://geuz.org/gmsh/#Download})
\item Blitz++ (you should be able to install this: \url{http://blitz.darwinports.com/})
\item mpi4py \url{http://mpi4py.scipy.org/docs/usrman/appendix.html}
\item scipy \url{http://www.scipy.org/Installing_SciPy/Mac_OS_X}
\item matplotlib \url{http://py-matplotlib.darwinports.com/}
\end{itemize}
If you succeed, could you post the steps on the Forum? Better yet, if you could provide an installation script, that would be awesome!


\section{Windows}
%
\par
It is possible to use Puma-EM on Windows... Through a Linux Virtual Machine running on VMWare \url{http://www.vmware.com/} for example! It might be possible to compile and use Puma-EM on Cygwin \url{http://www.cygwin.com/} but it has not been reported. Yet. 


\chapter{Running the code}

\section{Introduction}
%
\par
Your starting point is the configuration file \file{simulation\_parameters.py}. While it may be repellent at first (no graphical user interface?? Are you freakin' kiddin' me??), it is actually not so difficult to get acquainted with. It contains the parameters that will define the simulation, such as the frequency, the target, the type of result you want (RCS, bistatic RCS, array of dipoles excitation, antenna pattern), and some post-processing possibilities. 
%
\par
Once you have modified \file{simulation\_parameters.py} to suit your needs, simply type:
\begin{verbatim}
puma-em$ ./run.sh
\end{verbatim}
To run the code on the set of parameters that you have defined. The results of the run will be stored in \texttt{result} directory.

\section{CAD models and meshes}
%
\par
Puma-EM supports GMSH, and it is strongly advised to use it for your project. Explaining how to use GMSH is beyond the scope of this document. But here are a few facts. Basically, a CAD file comes with a \texttt{*.geo} extension, and is a written in a scripting language. A good starting point is to open one of the \texttt{geo} files and start playing with it, and visualise the result in GMSH. A mesh file comes with a \texttt{*.msh} extension. You don't need to know what's inside (nodes of triangles and nodes coordinates), Puma-EM can read it and interpret it. The good thing is that the density of the mesh will vary with the frequency (to follow the requirement that each RWG function be around $\lambda/10$ in size), so you don't need to worry about setting yourself the parameter that controls mesh size. Well, this is true for the targets shipped with Puma-EM. When designing your own target, you will make sure to parametrize the mesh size (look at the shipped targets to see how it is done).
%
\par
At the request of users, Puma-EM also supports 2 other mesh formats from proprietary CAD programs, GiD (mesh extension \texttt{*.msh}) and ANSYS (generates 2 mesh files, \file{ELIST.lis} and \file{NLIST.lis}). Below is explained how to specify the mesh format for Puma-EM. But beforehand, you must know that since these programs are proprietary, no scripting exists that allows parametrization as for GMSH. Therefore, before running Puma-EM, you will have to make sure that the mesh is generated, located in the correct directory (usually \texttt{puma-em/geo}), and that the mean RWG size is around $\lambda/10$.
%
\par
Support could easily be added for other mesh formats. If you want that, just post on the Puma-EM forum and join an example of the mesh format that has to be interpreted.

\section{Bistatic RCS computation of a target}
%
\par
This title recovers many possibilities, and we will review them separately. They are grouped here together, because bistatic means that you are primarily interested in knowing the scattered fields due to a given excitation, but not necessarily at the place of the excitation itself.

\subsection{The simple one: single electric dipole excitation}
\label{subsection:The simple one: single electric dipole excitation}
%
\par
Open \file{simulation\_parameters.py} with your favourite text editor. Only the relevant parameters will be reviewed. Do not modify the other parameters if you are unsure of what they do.

\subsubsection{Target}
%
\par
There are two parameters for the name of the target you want to simulate:
\begin{verbatim}
params_simu.pathToTarget = './geo'
params_simu.targetName = 'cubi'
\end{verbatim}
You should not change \parameter{params\_simu.pathToTarget}; that's where the geometry files and meshes are stored by Puma-EM. However, if your target file is located in \texttt{/somewhere/potato}, feel free to change \parameter{params\_simu.pathToTarget}. Also, the name of the target is given without its extension.

\subsubsection{Frequency}
%
\par
Next, the frequency of the source (in Hz units):
\begin{verbatim}
params_simu.f = 2.12e9
\end{verbatim}
%
\par
Next, the lc (characteristic length) factor. It will multiply lambda (the wavelength) to obtain the average edge length (lc) of the mesh. Usually: lc ~= lambda/10.
\begin{verbatim}
params_simu.lc_factor = 1.0/10.0
\end{verbatim}
%
\par
Then, you can define the dimensions of the target (in meters). It is only applicable to targets which have parameterized dimensions (see \file{sphere.geo} for example); undefined parameters will not impact the simulation. Unless you find a way to script your favourite mesher, it does not apply to another mesher than GMSH either.
\begin{verbatim}
params_simu.lx = .2
params_simu.ly = .2
params_simu.lz = .2
\end{verbatim}
The dimensions can also be given in terms of lambda:
\begin{verbatim}
params_simu.lx = 20.0 * c/params_simu.f
\end{verbatim}

\subsubsection{Mesh format}
%
\par
You have to choose the mesh format. Default is GMSH.
\begin{verbatim}
params_simu.meshFormat = MESH_FORMAT[0]
\end{verbatim}

\subsubsection{Type of simulation}
%
\par
Fast-forward to the parameters that define which type of computation---bistatic---we are going to perform:
\begin{verbatim}
params_simu.BISTATIC = 1
params_simu.MONOSTATIC_RCS = 0
params_simu.MONOSTATIC_SAR = 0
\end{verbatim}
In fact, bistatic defines a whole lot of possibilities, but for now we concentrate on the simple one electric dipole source.

\subsubsection{Bistatic simulation settings}
%
\par
We want just the dipole, remember? So:
\begin{verbatim}
params_simu.BISTATIC_EXCITATION_DIPOLES = 1
params_simu.BISTATIC_EXCITATION_PLANE_WAVE = 0
\end{verbatim}
If both parameters are set to 1, the excitation will be a combined one: plane wave + dipole.
%
\par
Next there is an \texttt{if} statement:
\begin{verbatim}
if params_simu.BISTATIC_EXCITATION_DIPOLES == 1:
    # do we receive our excitation from a user-supplied file?
    params_simu.BISTATIC_EXCITATION_DIPOLES_FROM_FILE = 0
\end{verbatim}
The above parameter \parameter{params\_simu.BISTATIC\_EXCITATION\_DIPOLES\_FROM\_FILE} tells if we define the excitation from a file or directly in the \file{simulation\_parameters.py} file. For now, that parameter is $0$. In that case, there is the following piece of parameters definition:
\begin{verbatim}
....
params_simu.BISTATIC_EXCITATION_DIPOLES = 1
    ....
    params_simu.BISTATIC_EXCITATION_DIPOLES_FROM_FILE = 0
    ....
        # in this case we define the excitation here and now
        # we have 2 lists for this purpose: 
        # dipoles and positions of these dipoles
        # example:
        # params_simu.J_src_x = [Jx1, Jx2, ..., Jxn]
        # params_simu.J_src_y = [Jy1, Jy2, ..., Jyn]
        # params_simu.J_src_z = [Jz1, Jz2, ..., Jzn]
        # and:
        # params_simu.r_J_src_x = [x1, x2, x3, ..., xn]
        # params_simu.r_J_src_y = [y1, y2, y3, ..., yn]
        # params_simu.r_J_src_z = [z1, z2, z3, ..., zn]
        # will yield the dipoles J1 = [Jx1, Jy1, Jz1], J2 = [Jx2, Jy2, Jz2], etc.
        # at the respective points r1 = [x1, y1, z1], r2 = [x2, y2, z2], etc.
        params_simu.J_src_x = [1.0+0.j]
        params_simu.J_src_y = [0.0+0.j]
        params_simu.J_src_z = [0.0+0.j]
        params_simu.r_J_src_x = [0.1]
        params_simu.r_J_src_y = [0.1]
        params_simu.r_J_src_z = [20.0]
\end{verbatim}
Pretty self-explanatory, huh? We have a dipole $\mathbf{J}_1 = [1, 0, 0]$ located at $\mathbf{r}_1 = [0.1, 0.1, 20]$. Dimensions for $\mathbf{r}_1$ are in meters.
%
\par
The same piece of code exists for magnetic dipoles.

\subsubsection{Results we want: EM fields sampling}

\paragraph{Arbitrary sampling of E-field}
%
\par
The following parameter allows one to sample the scattered electric field in arbitrary positions. For now it has to be defined in \file{simulation\_parameters.py}, but in the future it will optionally be defined through a file whose construction can be automated.
\begin{verbatim}
# sampling points: sampling of the resulting field 
# at user-specified points in space.
# It will be used only for BISTATIC
# The lists have to be of equal lengths.
# example:
# params_simu.r_obs_x = [x1, x2, x3, ..., xn]
# params_simu.r_obs_y = [y1, y2, y3, ..., yn]
# params_simu.r_obs_z = [z1, z2, z3, ..., zn]
# will yield the points r1 = [x1, y1, z1], r2 = [x2, y2, z2], etc.
params_simu.r_obs_x = [0.1, 0.2]
params_simu.r_obs_y = [0.1, 0.3]
params_simu.r_obs_z = [20.0, 20.1]
\end{verbatim}
In the above settings, the field is sampled at $\mathbf{r_1} = [0.1, 0.1, 20.0 ]$ and $\mathbf{r_2} = [0.2, 0.3, 20.1 ]$.
%
\par
This allows to visualize the field along lines, planes, volumes, curves, etc.

\paragraph{far-field sampling of E-field}
%
\par
This is controlled by the following lines:
\begin{verbatim}
# thetas
params_simu.START_THETA = pi/2.0
params_simu.STOP_THETA = pi
params_simu.AUTOMATIC_THETAS = False
params_simu.USER_DEFINED_NB_THETA = 1
# phis
params_simu.START_PHI = 0.0
params_simu.STOP_PHI = 2.0 * pi
params_simu.AUTOMATIC_PHIS = True
params_simu.USER_DEFINED_NB_PHI = 200
\end{verbatim}
%
\par
Normally the code provides "best angles of observation", best from a "field spatial information for minimal sampling size" point of view. If you want the program to choose the best points for $\theta$ for example, set \parameter{params\_simu.AUTOMATIC\_THETAS} to \texttt{True}. If you want to provide your own sampling points (because you need less/more angles, for example), set \parameter{params\_simu.AUTOMATIC\_THETAS} to \texttt{False}. If you chose 1 point only, and \parameter{params\_simu.AUTOMATIC\_THETAS} is \texttt{False}, then the point will correspond to \parameter{params\_simu.START\_THETA} for $\theta$. The same reasoning holds for $\phi$ parameters

\subsection{Another simple one: plane wave excitation}
%
\par
Now we want just the plane wave. So, everything else being equal, we set the following parameters:
\begin{verbatim}
params_simu.BISTATIC_EXCITATION_DIPOLES = 0
params_simu.BISTATIC_EXCITATION_PLANE_WAVE = 1
\end{verbatim}
Remember: if both parameters are set to 1, the excitation will be a combined one: plane wave + dipole. Then, to define the plane wave, one has to set:
\begin{verbatim}
if params_simu.BISTATIC_EXCITATION_PLANE_WAVE == 1:
    # origin, strength, phase and polarization of the plane wave
    params_simu.theta_inc = pi/2.0
    params_simu.phi_inc = pi/2.0
    params_simu.E_inc_theta = 1.0+0.j # the theta component
    params_simu.E_inc_phi = 0.0+0.j # the phi component
\end{verbatim}
Nothing to say here.

\subsection{Plurality of dipoles}
%
\par
This is similar to what is developed in section \ref{subsection:The simple one: single electric dipole excitation}. Except now we will learn how to define a plurality of dipoles (for modeling complex sources of current for example).

\subsubsection{Dipoles defined in \file{simulation\_parameters.py}}
%
\par
Let's recall that
\begin{verbatim}
params_simu.BISTATIC = 1
\end{verbatim}
and that
\begin{verbatim}
params_simu.BISTATIC_EXCITATION_DIPOLES = 1
params_simu.BISTATIC_EXCITATION_PLANE_WAVE = 0
\end{verbatim}
If both parameters are set to 1, the excitation will be a combined one: plane wave + dipole.
%
\par
We now define the sources:
\begin{verbatim}
params_simu.BISTATIC_EXCITATION_DIPOLES = 1
params_simu.BISTATIC_EXCITATION_PLANE_WAVE = 0
# now the details of each excitation
if params_simu.BISTATIC_EXCITATION_DIPOLES == 1:
    # do we receive our excitation from a user-supplied file?
    params_simu.BISTATIC_EXCITATION_DIPOLES_FROM_FILE = 0
    if params_simu.BISTATIC_EXCITATION_DIPOLES_FROM_FILE == 1:
        .....
        (see next section)
        .....
    else:
        # in this case we define the excitation here and now
        # we have 2 lists for this purpose: 
        # dipoles and positions of these dipoles
        # example:
        # params_simu.J_src_x = [Jx1, Jx2, ..., Jxn]
        # params_simu.J_src_y = [Jy1, Jy2, ..., Jyn]
        # params_simu.J_src_z = [Jz1, Jz2, ..., Jzn]
        # and:
        # params_simu.r_J_src_x = [x1, x2, x3, ..., xn]
        # params_simu.r_J_src_y = [y1, y2, y3, ..., yn]
        # params_simu.r_J_src_z = [z1, z2, z3, ..., zn]
        # will yield the dipoles J1 = [Jx1, Jy1, Jz1], J2 = [Jx2, Jy2, Jz2], etc.
        # at the respective points r1 = [x1, y1, z1], r2 = [x2, y2, z2], etc.
        params_simu.J_src_x = [1.0+0.j, 2.0+6.0j]
        params_simu.J_src_y = [0.0+0.j, 1.j]
        params_simu.J_src_z = [0.0+0.j, 0.0+0.j]
        params_simu.r_J_src_x = [0.1, 0.2]
        params_simu.r_J_src_y = [0.1, 0.3]
        params_simu.r_J_src_z = [20.0, 22.0]
        # the same but for magnetic dipoles. Leave empty if not needed.
        params_simu.M_src_x = [0.0+0.j]
        params_simu.M_src_y = [0.0+0.j]
        params_simu.M_src_z = [1.0+0.j]
        params_simu.r_M_src_x = [1.0]
        params_simu.r_M_src_y = [0.0]
        params_simu.r_M_src_z = [0.0]
\end{verbatim}
The above defines 2 electric dipoles, $\mathbf{J}_1 = [1, 0, 0]$ and $\mathbf{J}_2 = [2+6i, i, 0]$, respectively located at $\mathbf{r}_1 = [0.1, 0.1, 20]$ and $\mathbf{r}_2 = [0.2, 0.3, 22]$, and one magnetic dipole $\mathbf{M} = [0, 0, 1]$ located at $\mathbf{r} = [1, 0, 0]$. Dimensions for position vectors are in meters.
%
\par
You can realize how quickly cumbersome it becomes to define the dipoles in \file{simulation\_parameters.py}. This is why it is possible to define the dipoles through a user-supplied file, the subject of the nect section.

\subsubsection{Dipoles defined in user-supplied files}
%
\par
The following example shows you how to do this
\begin{verbatim}
if params_simu.BISTATIC_EXCITATION_DIPOLES == 1:
    # do we receive our excitation from a user-supplied file?
    params_simu.BISTATIC_EXCITATION_DIPOLES_FROM_FILE = 1
    if params_simu.BISTATIC_EXCITATION_DIPOLES_FROM_FILE == 1:
        # the name (with path) of the user-supplied excitation file. 
        # Set it to "" if empty
        params_simu.BISTATIC_EXCITATION_J_DIPOLES_FILENAME = "./J_dip_r_dip.txt"
        params_simu.BISTATIC_EXCITATION_M_DIPOLES_FILENAME = ""
        # the structure of the excitation file MUST BE AS FOLLOWS:
        # 1 line per dipole, as many lines as there are dipoles
        # each line has 9 columns that must be arranged as follows:
        #
        # real(J_x) imag(J_x) real(J_y) imag(J_y) real(J_z) imag(J_z) r_x r_y r_z
        #
        # where J = [J_x J_y J_z] is the dipole and r = [r_x r_y r_z] its origin.
\end{verbatim}
It is your responsibility to create a file named \file{J\_dip\_r\_dip.txt}, and arranged in 9 columns as explained, each line corresponding to a dipole. You can also do the same for magnetic dipoles.


\section{Monostatic RCS computation of a target}
%
\par
First Let's take a look at the following parameters:
\begin{verbatim}
params_simu.BISTATIC = 0
params_simu.MONOSTATIC_RCS = 1
params_simu.MONOSTATIC_SAR = 0
\end{verbatim}
There are two possibilities for doing monostatic computations: classic and SAR. We can do computations for the antenna polarization in vertical mode at emission and reception (VV following the $\theta$ angle), or horizontal mode at emission and reception (HH following the $\phi$ angle), or mixed (HV):
\begin{verbatim}
params_simu.COMPUTE_RCS_HH = 1
params_simu.COMPUTE_RCS_VV = 1
params_simu.COMPUTE_RCS_HV = 0
\end{verbatim}

\subsection{Classic RCS}
%
\par
We then define the angles we want to study. This is controlled by the following lines:
\begin{verbatim}
# thetas
params_simu.START_THETA = pi/2.0
params_simu.STOP_THETA = pi
params_simu.AUTOMATIC_THETAS = False
params_simu.USER_DEFINED_NB_THETA = 1
# phis
params_simu.START_PHI = 0.0
params_simu.STOP_PHI = 2.0 * pi
params_simu.AUTOMATIC_PHIS = True
params_simu.USER_DEFINED_NB_PHI = 200
\end{verbatim}
%
\par
Normally the code provides "best angles of observation", best from a "field spatial information for minimal sampling size" point of view. If you want the program to choose the best points for $\theta$ for example, set \parameter{params\_simu.AUTOMATIC\_THETAS} to \texttt{True}. If you want to provide your own sampling points (because you need less/more angles, for example), set \parameter{params\_simu.AUTOMATIC\_THETAS} to \texttt{False}. If you chose 1 point only, and \parameter{params\_simu.AUTOMATIC\_THETAS} is \texttt{False}, then the point will correspond to \parameter{params\_simu.START\_THETA} for $\theta$. The same reasoning holds for $\phi$ parameters
%
\par
Finally, for visualization, we can decide:
\begin{verbatim}
params_simu.SHOW_FIGURE = 1
\end{verbatim}

\subsection{Monostatic SAR}
%
\par
Instead of a classic, along $\theta$ or $\phi$, monostatic evaluation of a target, it is possible to gather SAR data by virtually ``flying'' an antenna in a plane and sample the fields at given points. For this we do:
\begin{verbatim}
params_simu.BISTATIC = 0
params_simu.MONOSTATIC_RCS = 0
params_simu.MONOSTATIC_SAR = 1
\end{verbatim}
%
\par
We then decide at which locations we want to sample the monostatic fields:
\begin{verbatim}
if params_simu.MONOSTATIC_SAR==1:
    # dipole antenna will "fly" in a plane defined by local x and y axis
    # we also need an origin for the plane, 
    # and a distribution of observation points
    params_simu.SAR_local_x_hat = [-1.0, 0.0, 0.0]
    params_simu.SAR_local_y_hat = [0.0, 0.0, 1.0]
    params_simu.SAR_plane_origin = [0.0, 50.0, 0.0]
    # span of the scanning rectangle (in meters)
    params_simu.SAR_x_span = 200.
    params_simu.SAR_y_span = 200.
    # offset of the scanning rectangle wrt its origin
    params_simu.SAR_x_span_offset = -100.
    params_simu.SAR_y_span_offset = -100.
    # the number of points in each direction
    params_simu.SAR_N_x_points = 8
    params_simu.SAR_N_y_points = 3
\end{verbatim}
This is self explanatory. 


\section{Antenna radiation pattern}
%
\par
This is in principle possible, although I haven't tried it. An antenna system comprises in general a waveguiding structure and a radiator. It is possible to excite the structure, with one dipole or a plurality of dipoles judiciously placed, and then to evaluate the bistatic scattering of the structure in the far field to obtain its radiation pattern.


\end{document}
